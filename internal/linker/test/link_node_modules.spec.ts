import * as fs from 'fs';
import * as path from 'path';

import * as linker from '../link_node_modules';

const BIN_DIR = `bazel-out/my-platform-fastbuild/bin`;

function mkdirp(p: string) {
  if (!fs.existsSync(p)) {
    mkdirp(path.dirname(p));
    fs.mkdirSync(p);
  }
}

// Mock out the creation of the modules manifest
function writeManifest(o: {}) {
  fs.writeFileSync('manifest.json', JSON.stringify(o, null, 2), 'utf-8');
}

function writeRunfiles(manifest: string[]) {
  fs.writeFileSync('runfiles.mf', manifest.join('\n'), 'utf-8');
  process.env['RUNFILES_MANIFEST_FILE'] = 'runfiles.mf';
}

describe('link_node_modules', () => {
  let workspace: string;

  beforeEach(() => {
    process.chdir(process.env['TEST_TMPDIR']!);
    // Prevent test isolation failures: each spec gets its own workspace
    workspace = `wksp_${Date.now()}`;
    // Create our local workspace where the build is running
    mkdirp(workspace);
  });

  it('should report when modules manifest absent', async () => {
    try {
      await (linker as any).main();
    } catch (expected) {
      expect(expected.message).toContain('requires one argument');
    }
    try {
      await (linker as any).main([]);
    } catch (expected) {
      expect(expected.message).toContain('requires one argument');
    }
    try {
      await (linker as any).main(['bad_path']);
    } catch (expected) {
      expect(expected.message).toContain('ENOENT');
    }
  });

  it('should handle first-party packages in workspace', async () => {
    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspace);

    // Create a package in the user workspace
    mkdirp('path/to/lib_a');
    fs.writeFileSync('path/to/lib_a/index.js', 'exports = {}', 'utf-8');

    // Create a package in a different workspace
    mkdirp('external/other_wksp/path/to/lib_b');
    fs.writeFileSync('external/other_wksp/path/to/lib_b/index.js', 'exports = {}', 'utf-8');

    // Create a package in bazel-bin
    mkdirp(`${BIN_DIR}/path/to/lib_c`);
    fs.writeFileSync(`${BIN_DIR}/path/to/lib_c/index.js`, 'exports = {}', 'utf-8');

    writeManifest({
      'bin': BIN_DIR,
      'modules': {
        'a': `${workspace}/path/to/lib_a`,
        'b': 'other_wksp/path/to/lib_b',
        'c': `${workspace}/path/to/lib_c`,
      },
      'workspace': workspace,
    });

    await linker.main(['manifest.json'], {dir: process.env['RUNFILES_DIR']} as any);

    // The linker expects to run as its own process, so it changes the wd
    process.chdir(path.join());
    expect(fs.readdirSync(path.join(process.env['TEST_TMPDIR']!, workspace, 'node_modules', 'a')))
        .toContain('index.js');
    expect(fs.readdirSync(path.join(process.env['TEST_TMPDIR']!, workspace, 'node_modules', 'b')))
        .toContain('index.js');
    expect(fs.readdirSync(path.join(process.env['TEST_TMPDIR']!, workspace, 'node_modules', 'c')))
        .toContain('index.js');
  });

  it('should handle third-party packages in runfiles', async () => {
    mkdirp('npm/node_modules/some-package');
    const idx = 'npm/node_modules/some-package/index.js';
    fs.writeFileSync(idx, 'exports = {}', 'utf-8');
    const runfilesManifest = [`${idx} ${path.resolve(idx)}`];

    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspace);
    // No first-party packages
    writeManifest({
      'bin': BIN_DIR,
      'root': 'npm/node_modules',
    });
    writeRunfiles(runfilesManifest);

    await linker.main(['manifest.json'], new linker.Runfiles());

    // The linker expects to run as its own process, so it changes the wd
    process.chdir(path.join(process.env['TEST_TMPDIR']!, workspace));
    expect(fs.readdirSync(path.join('node_modules', 'some-package'))).toContain('index.js');
  });
});